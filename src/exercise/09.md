# Les Interfaces

### ğŸ’¡ Les Interfaces en TypeScript

## ğŸ“ Tes notes

Detaille ce que tu as appris ici
`src/exercise/09.md`ouÂ surÂ uneÂ pageÂ [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Les types et les interfaces sont de prime abord similaires. Mais nous allons
voir lâ€™intÃ©rÃªt des interfaces

```tsx
// Type alias
type Person = {
  name: string
  age: number
}

function greet(person: Person) {
  return 'Hello ' + person.name
}
```

```tsx
//  Interface
interface Person {
  name: string
  age: number
}

function greet(person: Person) {
  return 'Hello ' + person.name
}
```

Au delÃ  de Ã§a les `interfaces` comblent un vide dans la programmation orientÃ©
objets (`POO`) en JavaScript.

Les classes sont apparues avec ES6 ce qui permet de faire de lâ€™hÃ©ritage avec
`extends`

```tsx
class Car {
  constructor(brand) {
    this.carname = brand
  }
  present() {
    return 'I have a ' + this.carname
  }
}

class Model extends Car {
  constructor(brand, mod) {
    super(brand)
    this.model = mod
  }
  show() {
    return this.present() + ', it is a ' + this.model
  }
}
mycar = new Model('Ford', 'Mustang')
```

Avec JavaScript (et dans la grande majoritÃ© des autres langage orientÃ© objet) il
nâ€™est pas possible dâ€™Ã©tendre plusieurs classes.

```tsx
class Model extends Car, Moto { // âŒ interdit
```

Les interfaces permettent de rÃ©soudre ce problÃ¨me et sont prÃ©sentes dans TS via
le _mot clef rÃ©servÃ©_ `implements`

```tsx
interface IFlyable {
  fly: (speed: any) => void
}
interface IRunnable {
  run: (speed: any) => void
}

// Implementation
class SpeederMan implements IFlyable, IRunnable {
  fly(speed: string) {
    console.log('SpeederMan flying at a speed of ' + speed)
  }
  run(speed: string) {
    console.log('SpeederMan run at ' + speed + '')
  }
}
```

<aside>
ğŸ’¡ Contrairement aux `types` les interfaces peuvent Ãªtre redÃ©finies, les propriÃ©tÃ© sont ainsi mergÃ©es

</aside>

```tsx
interface User {
  firstname: string
}
interface User {
  lastname: string
}
let user: User //aura les propriÃ©tÃ©s firstname et lastname
```

## Exercice

Nous avons une modÃ©lisation Annimal / Cat

```tsx
interface IName {
  name: string
  printName: () => string
}
interface Runnable {
  run: () => void
}
interface Drinkable {
  drink: () => void
}

class Animal implements IName {
  // name: string | undefined
  nbLeg: number
  underwater: boolean
  constructor(name: string, nbLeg: number, underwater: boolean) {
    this.name = name
    this.nbLeg = nbLeg
    this.underwater = underwater
  }
  name: string
  printName() {
    console.log(`Mon nom est ${this.name}`)
    return this.name
  }
}

class Cat extends Animal implements Runnable, Drinkable {
  constructor(name: string) {
    super(name, 4, false)
  }
  run() {
    console.log(`Je cours`)
  }
  drink() {
    console.log(`Je bois`)
  }
}

const tigrou = new Cat('Tigrou')
tigrou.run()
tigrou.drink()
displayText(`Nom du chat ${tigrou.printName()}`)
```

ğŸ¶ ImplÃ©mente correctement Lâ€™animal `Dog`. Qui est la mÃªme chose que `Cat`

- ImplÃ©mente ensuite `Fish` en Ã©tendant `Animal` et en crÃ©ant une interface
  `Swimable` ayant la fonction `swim()`

<aside>
ğŸ’¡ Note quâ€™un poisson ne bois pas

</aside>

## Bonus

### 1. ğŸš€ Extending an interface

On peut avoir de nombreuses interfaces Ã  implÃ©menter. Il est possible dâ€™Ã©tendre
des interfaces ce qui permet dâ€™Ã©viter la duplication et ce qui permet aussi de
regrouper des interfaces

ğŸ¶ Dans cet exercice on souhaite regrouper les interfaces `Runnable` et
`Drinkable` dans une super Interface `Mammal` qui reprÃ©sente les
caractÃ©ristiques dâ€™un mammifÃ¨re.

- CrÃ©Ã© lâ€™interface `Mammal` et applique la

ğŸ“‘ Le lien vers doc `extends`
[https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces)

### 2. ğŸš€ Extending a type via intersections

Il est possible dâ€™Ã©tendre Ã©galement via des `types intersections`

```tsx
interface Animal {
  name: string
}

interface Bear extends Animal {
  honey: boolean
}

const bear = getBear()
bear.name
bear.honey
```

- Via les type intersections

```tsx
type Animal = {
  name: string
}

type Bear = Animal & {
  honey: boolean
}

const bear = getBear()
bear.name
bear.honey
```

ğŸ¶ Dans cet exercice utilise cette technique pour dÃ©clarer `Mammal`

### 3. ğŸš€ Interfaces parameters

Parfois une fonction nâ€™a pas besoin de connaitre tout le dÃ©tail de lâ€™objet mais
seulement quelques propriÃ©tÃ©s. Par exemple

```tsx
function sayHelloAndRun(runner: Runnable) {
  console.log('Hello')
  runner.run()
}
```

ğŸ¶ Dans cette exercice crÃ©Ã© une fonction `doSomeThingWithDrinkers` qui prend en
paramÃ¨tre un `drinker` . appelle ensuite

- `displayText(Je bois)`
- `drinker.drinker()`

<aside>
ğŸ’¡ Assure toi que cette fonction ne compile pas pour un `fish`

</aside>

## ğŸœ Feedback

Remplir le formulaire le
[formulaire de FeedBack.](https://go.mikecodeur.com/cours-react-avis?entry.1912869708=TypeScript%20PRO&entry.1430994900=2.Les%20Fondamentaux&entry.533578441=01%20Les%20interfaces)
